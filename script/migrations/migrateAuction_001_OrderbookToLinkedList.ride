{-# STDLIB_VERSION 3 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}
#
# Migration of Orderbook to Linked List 
#

#-------------------Base functions----------------------
func getNumberByKey(key: String) = {
    match getInteger(this, key) {
            case a:Int => a
            case _ => 0
    }
}
func getStringByKey(key: String) = {
    match getString(this, key) {
            case a:String => a
            case _ => ""
    }
}

#-------------------Keys--------------------------------
let FirstOrderKey = "order_first"
let firstOrder = getStringByKey(FirstOrderKey)


#-------------------Get functions----------------------
func getPrevOrderKey(orderId: String) = "order_prev_" + orderId
func getNextOrderKey(orderId: String) = "order_next_" + orderId
func getPrevOrder(id: String) = getStringByKey(getPrevOrderKey(id))
func getNextOrder(id: String) = getStringByKey(getNextOrderKey(id))
func getLastOrderOwnerKey(owner: String) = "last_order_owner_" + owner
func getOrderOwnerKey(orderId: String) = "order_owner_" + orderId
func getOrderOwner(id : String) = getStringByKey(getOrderOwnerKey(id))


#-------------------Migration specific keys----------------------
let MigrationOrderCurrentIndexKey = "migration_current_order"
let currentMigrationOrderIndex = getNumberByKey(MigrationOrderCurrentIndexKey)

#-------------------Callable---------------------------
@Callable(i)
func migrateOrder() = {
    let orderbook = getStringByKey("orderbook")

    if(orderbook == "")
        then throw("empty orderbook")
    else {
        let orders = orderbook.split("_")
        let owner = toString(i.caller)
        if(size(orders) <= currentMigrationOrderIndex)
            then throw("currentMigrationOrderIndex is out of orderbook size")
        else if(orders[currentMigrationOrderIndex] == "")
            then throw("empty order")
        else {
            let firstOldOrder = orders[currentMigrationOrderIndex]
            let nextOldOrder = orders[currentMigrationOrderIndex+1]
            let prevOldOrder = if currentMigrationOrderIndex == 0 then "" else orders[currentMigrationOrderIndex-1]
            WriteSet([
                DataEntry(getLastOrderOwnerKey(owner), firstOldOrder),
                DataEntry(getPrevOrderKey(firstOldOrder), prevOldOrder),
                DataEntry(getNextOrderKey(firstOldOrder), nextOldOrder),

                DataEntry(FirstOrderKey, if firstOrder == "" then firstOldOrder else firstOrder),
                DataEntry(MigrationOrderCurrentIndexKey, currentMigrationOrderIndex + 1)
            ])
        }
    }
}

@Verifier(tx)
func verify() = {
    let pubKeyAdminsList = [
        "BLEoguzPVKVTfXxxT3W7Rqf8aUm2ggC9Vemd2MQawM2G",
        "FWVffYr2ALmHMejZm3WqeLz6Sdym3gLFGtJn4KTwyU5x",
        "3Wh2LaWcb5gg7K2pPcW3Ep6EAuRBzYkAgrdpt43jTDFa",
        "5WRXFSjwcTbNfKcJs8ZqXmSSWYsSVJUtMvMqZj5hH4Nc"
    ]
    let count =
        (if(sigVerify(tx.bodyBytes, tx.proofs[0], fromBase58String(pubKeyAdminsList[0]))) then 1 else 0) +
        (if(sigVerify(tx.bodyBytes, tx.proofs[1], fromBase58String(pubKeyAdminsList[1]))) then 1 else 0) +
        (if(sigVerify(tx.bodyBytes, tx.proofs[2], fromBase58String(pubKeyAdminsList[2]))) then 1 else 0) +
        (if(sigVerify(tx.bodyBytes, tx.proofs[3], fromBase58String(pubKeyAdminsList[3]))) then 2 else 0)

    count >= 3
}