{-# STDLIB_VERSION 3 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}
#-------------------Base functions----------------------
func getNumberByKey(key: String) = {
    match getInteger(this, key) {
            case a:Int => a
            case _ => 0
    }
}
func getStringByKey(key: String) = {
    match getString(this, key) {
            case a:String => a
            case _ => ""
    }
}
func getBoolByKey(key: String) = {
    match getBoolean(this, key) {
            case a:Boolean => a
            case _ => false
    }
}
func getNumberByAddressAndKey(address: String, key: String) = {
    match getInteger(addressFromStringValue(address), key) {
            case a:Int => a
            case _ => 0
    }
}
func getStringByAddressAndKey(address: String, key: String) = {
     match getString(addressFromStringValue(address), key) {
            case a:String => a
            case _ => ""
    }
}
func getBoolByAddressAndKey(address: String, key: String) = {
     match getBoolean(addressFromStringValue(address), key) {
            case a:Boolean => a
            case _ => false
    }
}

#-------------------Old base tokens to NSBT migration vars ans funcs----------------------
let NodeOracleProviderPubKeyKey = "node_oracle_provider"
let nodeOracleProviderPubKey = fromBase58String(getStringByKey(NodeOracleProviderPubKeyKey))
let baseAssetId = fromBase58String("6nSpVyNH7yM69eg446wrQR94ipbbcmZMU1ENPwanC97g") # NSBT with 6 decimals as USDN does
let deprecatedBaseAssetId = fromBase58String("975akZBfnMj513U7MZaHKzQrmsEx5aE3wdWKTrHBhbjF") # Old base tokens with 0 decimals
let PAULI = 1000000
let CANCELED = "canceled"
let NEW = "new"
let FILLED = "filled"

let FirstOrderKey = "order_first"
let LastOrderKey = "order_last"
let LiquidationContractKey = "liquidation_contract"
let liquidationContract = getStringByKey(LiquidationContractKey)

let firstOrder = getStringByAddressAndKey(liquidationContract, FirstOrderKey)
let lastOrder = getStringByAddressAndKey(liquidationContract, LastOrderKey)

func getOrderPrevKey(orderId: String) = "order_prev_" + orderId
func getOrderNextKey(orderId: String) = "order_next_" + orderId
func getOrderTotalKey(orderId: String) = "order_total_" + orderId
func getOrderOwnerKey(orderId: String) = "order_owner_" + orderId
func getOrderStatusKey(orderId: String) = "order_status_" + orderId
func getOrderFilledTotalKey(orderId: String) = "order_filled_total_" + orderId

func getOrderTotal(id : String) = getNumberByAddressAndKey(liquidationContract, getOrderTotalKey(id))
func getOrderOwner(id : String) = getStringByAddressAndKey(liquidationContract, getOrderOwnerKey(id))
func getOrderStatus(id : String) = getStringByAddressAndKey(liquidationContract, getOrderStatusKey(id))
func getOrderFilledTotal(id : String) = getNumberByAddressAndKey(liquidationContract, getOrderFilledTotalKey(id))
func getOrderPrev(id: String) = getStringByAddressAndKey(liquidationContract, getOrderPrevKey(id))
func getOrderNext(id: String) = getStringByAddressAndKey(liquidationContract, getOrderNextKey(id))

# Old base tokens to NSBT liquidation orders migration method (temporary method)
# [called by pacemaker]
@Callable(i)
func migrationTransferToLiquidation() = {
    let keyLastMigratedOrder = "lastMigratedOrderId_migration_usdnb2nsbt"
    let finalStatus = "migrated"
    let isLastMigratedAsFirstOrder = getStringByKey(keyLastMigratedOrder) == ""
    let lastMigratedOrderId = getStringByKey(keyLastMigratedOrder)
    let currentOrderId = if(isLastMigratedAsFirstOrder) then firstOrder else getOrderNext(lastMigratedOrderId)
    let keyStatusLiquidationMigration = "status_migration_usdnb2nsbt_" + currentOrderId
    let orderAmount = getOrderTotal(currentOrderId) - getOrderFilledTotal(currentOrderId)
    let orderOwner = addressFromStringValue(getOrderOwner(currentOrderId))
    let orderStatus = getOrderStatus(currentOrderId)
    let migrationStatus = getStringByKey(keyStatusLiquidationMigration)

    if(orderAmount <= 0 || orderStatus != NEW)
        then throw("error: invalid order")
    else if (migrationStatus == finalStatus)
        then throw("error: order has already migrated")
    else if (lastOrder == lastMigratedOrderId)
        then throw("status ok: all order has already migrated or nothing to migrate")
    else ScriptResult(
        WriteSet([
            DataEntry(keyStatusLiquidationMigration, finalStatus),
            DataEntry(keyLastMigratedOrder, currentOrderId)
        ]),
        TransferSet([ScriptTransfer(addressFromStringValue(liquidationContract), orderAmount*PAULI, baseAssetId)])
    )

}

# LeaseCancelTransaction depends from swapNeutrinoToWaves() result i.e. waves amount is not enought for future swaps
# or end of leasing time
@Verifier(tx)
 func verify() = {
    let id = toBase58String(tx.id)
    match tx {
        case leasingTx: LeaseTransaction | LeaseCancelTransaction =>
            sigVerify(tx.bodyBytes, tx.proofs[0], nodeOracleProviderPubKey)
        case _ => {
            let pubKeyAdminsList = [
                "BLEoguzPVKVTfXxxT3W7Rqf8aUm2ggC9Vemd2MQawM2G",
                "FWVffYr2ALmHMejZm3WqeLz6Sdym3gLFGtJn4KTwyU5x",
                "3Wh2LaWcb5gg7K2pPcW3Ep6EAuRBzYkAgrdpt43jTDFa",
                "5WRXFSjwcTbNfKcJs8ZqXmSSWYsSVJUtMvMqZj5hH4Nc"
            ]
            let count =
                (if(sigVerify(tx.bodyBytes, tx.proofs[0], fromBase58String(pubKeyAdminsList[0]))) then 1 else 0) +
                (if(sigVerify(tx.bodyBytes, tx.proofs[1], fromBase58String(pubKeyAdminsList[1]))) then 1 else 0) +
                (if(sigVerify(tx.bodyBytes, tx.proofs[2], fromBase58String(pubKeyAdminsList[2]))) then 1 else 0) +
                (if(sigVerify(tx.bodyBytes, tx.proofs[3], fromBase58String(pubKeyAdminsList[3]))) then 2 else 0)

            count >= 3
        }
    }
}